# ==============================================================================
# LoadCSCBranchArticle Module Validation Configuration - VERSION 3.1
# esqltest Framework Configuration File - INFORMIX COMPATIBLE
# 
# Module: pharmos.outbound.csc_load/dev/src/loadcscbrancharticle
# Purpose: Validate branch article data loading from inbound to outbound DB
# Author: AI Assistant  
# Date: 2025-01-29
# Version: 3.1 (Fixed Informix Syntax and Connection Issues)
# ==============================================================================

[general]
database=ich21@zdev21_tcp
test_capture_entries_count=10
persistent_connection=0
separator=;
timeout=300
commit_interval=1

# ==============================================================================
# PHASE 1: TABLE STRUCTURE SETUP - Create regular tables for testing
# ==============================================================================

# Create source table (simulates inbound artikelf) - Using regular table instead of TEMP
[transaction00]
sql=CREATE TABLE test_artikelf_source ( 
    filialnr INTEGER NOT NULL, 
    artikel_nr INTEGER NOT NULL, 
    besla_nr INTEGER, 
    bestand_min INTEGER, 
    artikelaktiv CHAR(1), 
    lagerfachnr CHAR(10), 
    offene_bestmenge INTEGER, 
    datum_aender INTEGER NOT NULL, 
    openorderqty_noteffective INTEGER 
);

# Create target table (simulates cscbrancharticle)
[transaction01]
sql=CREATE TABLE test_cscbrancharticle ( 
    filialnr INTEGER NOT NULL, 
    artikel_nr INTEGER NOT NULL, 
    besla_nr INTEGER, 
    bestand_min INTEGER, 
    artikelaktiv CHAR(1), 
    lagerfachnr CHAR(10), 
    offene_bestmenge INTEGER, 
    openorderqty_noteffective INTEGER, 
    lastupdatedate INTEGER DEFAULT 0 
);

# Create processing table (simulates tmp_artikelf)
[transaction02]
sql=CREATE TABLE test_processing_artikelf ( 
    filialnr INTEGER, 
    artikel_nr INTEGER, 
    besla_nr INTEGER, 
    bestand_min INTEGER, 
    artikelaktiv CHAR(1), 
    lagerfachnr CHAR(10), 
    offene_bestmenge INTEGER, 
    datum_aender INTEGER, 
    openorderqty_noteffective INTEGER 
);

# Create branch reference data
[transaction03]
sql=CREATE TABLE test_branch_reference ( 
    filialnr INTEGER NOT NULL, 
    branchname VARCHAR(40), 
    region VARCHAR(20), 
    active_flag INTEGER DEFAULT 1 
);

# Create validation results table
[transaction04]
sql=CREATE TABLE test_validation_results ( 
    validation_type VARCHAR(50), 
    metric_name VARCHAR(50), 
    metric_value INTEGER, 
    description VARCHAR(100) 
);

# ==============================================================================
# PHASE 2: REFERENCE DATA LOADING - Load test data
# ==============================================================================

# Load branch reference data
[transaction05]
sql=INSERT INTO test_branch_reference (filialnr, branchname, region, active_flag) VALUES (10, 'Central Branch Berlin', 'North', 1);

[transaction06]
sql=INSERT INTO test_branch_reference (filialnr, branchname, region, active_flag) VALUES (20, 'Regional Branch Munich', 'South', 1);

[transaction07]
sql=INSERT INTO test_branch_reference (filialnr, branchname, region, active_flag) VALUES (30, 'Metro Branch Vienna', 'Central', 1);

# Load initial historical data in target table
[transaction08]
sql=INSERT INTO test_cscbrancharticle (filialnr, artikel_nr, besla_nr, bestand_min, artikelaktiv, lagerfachnr, offene_bestmenge, openorderqty_noteffective, lastupdatedate) VALUES (10, 100001, 501, 25, 'Y', 'A001', 150, 75, 20250125);

[transaction09]
sql=INSERT INTO test_cscbrancharticle (filialnr, artikel_nr, besla_nr, bestand_min, artikelaktiv, lagerfachnr, offene_bestmenge, openorderqty_noteffective, lastupdatedate) VALUES (10, 100002, 502, 30, 'Y', 'A002', 200, 100, 20250125);

[transaction10]
sql=INSERT INTO test_cscbrancharticle (filialnr, artikel_nr, besla_nr, bestand_min, artikelaktiv, lagerfachnr, offene_bestmenge, openorderqty_noteffective, lastupdatedate) VALUES (20, 100001, 503, 20, 'Y', 'B001', 180, 90, 20250125);

# Load source data (simulates inbound artikelf with mixed scenarios)
[transaction11]
sql=INSERT INTO test_artikelf_source (filialnr, artikel_nr, besla_nr, bestand_min, artikelaktiv, lagerfachnr, offene_bestmenge, datum_aender, openorderqty_noteffective) VALUES (10, 100001, 501, 30, 'Y', 'A001', 175, 20250126, 80);

[transaction12]
sql=INSERT INTO test_artikelf_source (filialnr, artikel_nr, besla_nr, bestand_min, artikelaktiv, lagerfachnr, offene_bestmenge, datum_aender, openorderqty_noteffective) VALUES (10, 100003, 504, 15, 'Y', 'A003', 120, 20250126, 60);

[transaction13]
sql=INSERT INTO test_artikelf_source (filialnr, artikel_nr, besla_nr, bestand_min, artikelaktiv, lagerfachnr, offene_bestmenge, datum_aender, openorderqty_noteffective) VALUES (30, 100001, 505, 25, 'Y', 'C001', 160, 20250126, 85);

# ==============================================================================
# PHASE 3: BASIC QUERY VALIDATION - Test core operations
# ==============================================================================

# Test data validation - count records
[transaction14]
sql=SELECT (COUNT(*) || ';TOTAL_BRANCH_RECORDS') AS result FROM test_branch_reference;
header=count;description

[transaction15]
sql=SELECT (COUNT(*) || ';TOTAL_SOURCE_RECORDS') AS result FROM test_artikelf_source;
header=count;description

[transaction16]
sql=SELECT (COUNT(*) || ';TOTAL_TARGET_RECORDS') AS result FROM test_cscbrancharticle;
header=count;description

# ==============================================================================
# PHASE 4: INCREMENTAL LOADING SIMULATION - Test core module logic
# ==============================================================================

# Test incremental data selection (simulates module's core query)
[transaction17]
sql=SELECT (s.filialnr || ';' || s.artikel_nr || ';' || 
           CASE WHEN s.besla_nr IS NULL THEN 'NULL' ELSE s.besla_nr END || ';' || 
           CASE WHEN s.bestand_min IS NULL THEN 'NULL' ELSE s.bestand_min END || ';' || 
           CASE WHEN s.artikelaktiv IS NULL THEN 'NULL' ELSE s.artikelaktiv END || ';' || 
           CASE WHEN s.lagerfachnr IS NULL THEN 'NULL' ELSE s.lagerfachnr END || ';' || 
           CASE WHEN s.offene_bestmenge IS NULL THEN 'NULL' ELSE s.offene_bestmenge END || ';' || 
           s.datum_aender || ';' || 
           CASE WHEN s.openorderqty_noteffective IS NULL THEN 'NULL' ELSE s.openorderqty_noteffective END) AS result 
FROM test_artikelf_source s 
WHERE s.filialnr = 10 
  AND s.datum_aender >= (SELECT NVL(MAX(lastupdatedate), 0) 
                         FROM test_cscbrancharticle 
                         WHERE filialnr = 10) 
ORDER BY s.artikel_nr;
header=filialnr;artikel_nr;besla_nr;bestand_min;artikelaktiv;lagerfachnr;offene_bestmenge;datum_aender;openorderqty_noteffective

# Load processing table
[transaction18]
sql=DELETE FROM test_processing_artikelf;

[transaction19]
sql=INSERT INTO test_processing_artikelf 
SELECT filialnr, artikel_nr, besla_nr, bestand_min, artikelaktiv, lagerfachnr, offene_bestmenge, datum_aender, openorderqty_noteffective 
FROM test_artikelf_source 
WHERE filialnr = 10 
  AND datum_aender >= (SELECT NVL(MAX(lastupdatedate), 0) 
                       FROM test_cscbrancharticle 
                       WHERE filialnr = 10);

# Validate processing table load
[transaction20]
sql=SELECT (COUNT(*) || ';PROCESSING_RECORDS_LOADED') AS result 
FROM test_processing_artikelf;
header=count;description

# ==============================================================================
# PHASE 5: MERGE OPERATION TESTING - Using UPDATE/INSERT approach
# ==============================================================================

# Execute UPDATE operation for existing records
[transaction21]
sql=UPDATE test_cscbrancharticle 
SET besla_nr = (SELECT taf.besla_nr FROM test_processing_artikelf taf 
                WHERE taf.filialnr = test_cscbrancharticle.filialnr 
                AND taf.artikel_nr = test_cscbrancharticle.artikel_nr), 
    bestand_min = (SELECT taf.bestand_min FROM test_processing_artikelf taf 
                   WHERE taf.filialnr = test_cscbrancharticle.filialnr 
                   AND taf.artikel_nr = test_cscbrancharticle.artikel_nr), 
    artikelaktiv = (SELECT taf.artikelaktiv FROM test_processing_artikelf taf 
                    WHERE taf.filialnr = test_cscbrancharticle.filialnr 
                    AND taf.artikel_nr = test_cscbrancharticle.artikel_nr), 
    lagerfachnr = (SELECT taf.lagerfachnr FROM test_processing_artikelf taf 
                   WHERE taf.filialnr = test_cscbrancharticle.filialnr 
                   AND taf.artikel_nr = test_cscbrancharticle.artikel_nr), 
    offene_bestmenge = (SELECT taf.offene_bestmenge FROM test_processing_artikelf taf 
                        WHERE taf.filialnr = test_cscbrancharticle.filialnr 
                        AND taf.artikel_nr = test_cscbrancharticle.artikel_nr), 
    openorderqty_noteffective = (SELECT taf.openorderqty_noteffective FROM test_processing_artikelf taf 
                                 WHERE taf.filialnr = test_cscbrancharticle.filialnr 
                                 AND taf.artikel_nr = test_cscbrancharticle.artikel_nr), 
    lastupdatedate = 20250126 
WHERE EXISTS (SELECT 1 FROM test_processing_artikelf taf 
              WHERE taf.filialnr = test_cscbrancharticle.filialnr 
              AND taf.artikel_nr = test_cscbrancharticle.artikel_nr);

# Execute INSERT operation for new records
[transaction22]
sql=INSERT INTO test_cscbrancharticle (filialnr, artikel_nr, besla_nr, bestand_min, artikelaktiv, lagerfachnr, offene_bestmenge, openorderqty_noteffective, lastupdatedate) 
SELECT taf.filialnr, taf.artikel_nr, taf.besla_nr, taf.bestand_min, taf.artikelaktiv, taf.lagerfachnr, taf.offene_bestmenge, taf.openorderqty_noteffective, 20250126 
FROM test_processing_artikelf taf 
WHERE NOT EXISTS (SELECT 1 FROM test_cscbrancharticle cba 
                  WHERE cba.filialnr = taf.filialnr 
                  AND cba.artikel_nr = taf.artikel_nr);

# Count records updated today
[transaction23]
sql=INSERT INTO test_validation_results 
SELECT 'MERGE_SUMMARY', 'updated_today', COUNT(*), 'Records updated today' 
FROM test_cscbrancharticle 
WHERE lastupdatedate = 20250126;

# Count total records
[transaction24]
sql=INSERT INTO test_validation_results 
SELECT 'MERGE_SUMMARY', 'total_records', COUNT(*), 'Total records in table' 
FROM test_cscbrancharticle;

# Display MERGE summary results
[transaction25]
sql=SELECT (validation_type || ';' || metric_name || ';' || metric_value || ';' || description) AS result 
FROM test_validation_results 
WHERE validation_type = 'MERGE_SUMMARY' 
ORDER BY metric_name;
header=operation;metric;value;description

# Test record-level validation after MERGE
[transaction26]
sql=SELECT (cba.filialnr || ';' || cba.artikel_nr || ';' || 
           CASE WHEN cba.besla_nr IS NULL THEN 'NULL' ELSE cba.besla_nr END || ';' || 
           CASE WHEN cba.bestand_min IS NULL THEN 'NULL' ELSE cba.bestand_min END || ';' || 
           CASE WHEN cba.artikelaktiv IS NULL THEN 'NULL' ELSE cba.artikelaktiv END || ';' || 
           CASE WHEN cba.lagerfachnr IS NULL THEN 'NULL' ELSE cba.lagerfachnr END || ';' || 
           CASE WHEN cba.offene_bestmenge IS NULL THEN 'NULL' ELSE cba.offene_bestmenge END || ';' || 
           CASE WHEN cba.openorderqty_noteffective IS NULL THEN 'NULL' ELSE cba.openorderqty_noteffective END || ';' || 
           cba.lastupdatedate) AS result 
FROM test_cscbrancharticle cba 
WHERE cba.filialnr = 10 AND cba.lastupdatedate = 20250126 
ORDER BY cba.artikel_nr;
header=filialnr;artikel_nr;besla_nr;bestand_min;artikelaktiv;lagerfachnr;offene_bestmenge;openorderqty_noteffective;lastupdatedate

# ==============================================================================
# PHASE 6: DATA CLEANUP SIMULATION - Test deletion of outdated records
# ==============================================================================

# Identify records for cleanup
[transaction27]
sql=SELECT (cba.filialnr || ';' || cba.artikel_nr || ';' || 
           CASE WHEN cba.besla_nr IS NULL THEN 'NULL' ELSE cba.besla_nr END || ';CLEANUP_CANDIDATE') AS result 
FROM test_cscbrancharticle cba 
WHERE cba.filialnr = 10 
  AND NOT EXISTS (SELECT 1 FROM test_artikelf_source src 
                  WHERE cba.filialnr = src.filialnr AND cba.artikel_nr = src.artikel_nr) 
ORDER BY cba.artikel_nr;
header=filialnr;artikel_nr;besla_nr;cleanup_status

# Execute cleanup deletion
[transaction28]
sql=DELETE FROM test_cscbrancharticle 
WHERE filialnr = 10 
  AND NOT EXISTS (SELECT 1 FROM test_artikelf_source src 
                  WHERE test_cscbrancharticle.filialnr = src.filialnr 
                  AND test_cscbrancharticle.artikel_nr = src.artikel_nr);

# Validate cleanup results
[transaction29]
sql=SELECT (COUNT(*) || ';RECORDS_AFTER_CLEANUP') AS result 
FROM test_cscbrancharticle 
WHERE filialnr = 10;
header=count;description

# ==============================================================================
# PHASE 7: FINAL VALIDATION - Comprehensive data integrity check
# ==============================================================================

# Final record counts and validation
[transaction30]
sql=INSERT INTO test_validation_results 
SELECT 'FINAL_VALIDATION', 'total_records', COUNT(*), 'Total records in final table' 
FROM test_cscbrancharticle;

[transaction31]
sql=INSERT INTO test_validation_results 
SELECT 'FINAL_VALIDATION', 'unique_branches', COUNT(DISTINCT filialnr), 'Number of unique branches' 
FROM test_cscbrancharticle;

[transaction32]
sql=INSERT INTO test_validation_results 
SELECT 'FINAL_VALIDATION', 'unique_articles', COUNT(DISTINCT artikel_nr), 'Number of unique articles' 
FROM test_cscbrancharticle;

# Display final validation results
[transaction33]
sql=SELECT (validation_type || ';' || metric_name || ';' || metric_value || ';' || description) AS result 
FROM test_validation_results 
WHERE validation_type = 'FINAL_VALIDATION' 
ORDER BY metric_name;
header=validation_type;metric;value;description

# ==============================================================================
# PHASE 8: CLEANUP - Drop test tables and finish
# ==============================================================================

# Drop all test tables
[transaction34]
sql=DROP TABLE test_artikelf_source;

[transaction35]
sql=DROP TABLE test_cscbrancharticle;

[transaction36]
sql=DROP TABLE test_processing_artikelf;

[transaction37]
sql=DROP TABLE test_branch_reference;

[transaction38]
sql=DROP TABLE test_validation_results;

# Final cleanup verification
[transaction39]
sql=SELECT (COUNT(*) || ';REMAINING_TEST_TABLES') AS result 
FROM systables WHERE tabname LIKE 'test_%';
header=count;description

# ==============================================================================
# END OF CONFIGURATION
# ==============================================================================